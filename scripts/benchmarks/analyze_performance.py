#!/usr/bin/env python3
"""
Performance Analysis Tool for LLM with Metal GPU Acceleration

This script analyzes the monitoring logs generated by start_optimized.sh
and creates visualizations of GPU memory usage and CPU usage over time.
"""

import os
import argparse
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import glob
from typing import List, Tuple, Optional

def parse_timestamp(ts: str) -> datetime:
    """Parse timestamp from log format."""
    try:
        return datetime.strptime(ts, '%Y-%m-%d_%H:%M:%S')
    except ValueError:
        return datetime.strptime(ts, '%Y%m%d_%H%M%S')

def load_monitoring_logs(log_path: Optional[str] = None) -> pd.DataFrame:
    """Load monitoring logs from file or directory."""
    if log_path is None:
        # Find most recent log file in monitoring directory
        log_files = glob.glob('monitoring/gpu_memory_*.log')
        if not log_files:
            print("No monitoring logs found in 'monitoring/' directory")
            return pd.DataFrame()
        
        log_path = max(log_files, key=os.path.getctime)
        print(f"Using most recent log file: {log_path}")
    
    if os.path.isdir(log_path):
        # If it's a directory, find the most recent log file
        log_files = glob.glob(os.path.join(log_path, 'gpu_memory_*.log'))
        if not log_files:
            print(f"No monitoring logs found in '{log_path}' directory")
            return pd.DataFrame()
        
        log_path = max(log_files, key=os.path.getctime)
        print(f"Using most recent log file in directory: {log_path}")
    
    try:
        # Load the CSV file
        df = pd.read_csv(log_path)
        
        # Process data
        df['timestamp'] = df['timestamp'].apply(parse_timestamp)
        
        # Handle special values
        df.replace('N/A', float('nan'), inplace=True)
        
        return df
    except Exception as e:
        print(f"Error loading log file {log_path}: {e}")
        return pd.DataFrame()

def plot_memory_usage(df: pd.DataFrame, output_file: Optional[str] = None) -> None:
    """Plot GPU memory usage and CPU usage over time."""
    if df.empty:
        print("No data to plot")
        return
    
    # Create figure with two y-axes
    fig, ax1 = plt.subplots(figsize=(12, 6))
    
    # Set title and labels
    plt.title('LLM Performance Metrics with Metal GPU Acceleration', fontsize=14)
    ax1.set_xlabel('Time', fontsize=12)
    ax1.set_ylabel('GPU Memory Usage (MB)', color='tab:blue', fontsize=12)
    
    # Only include non-NaN GPU memory values
    gpu_df = df[df['gpu_memory_used_mb'].notna()]
    if not gpu_df.empty:
        # Plot GPU memory usage
        ax1.plot(gpu_df['timestamp'], gpu_df['gpu_memory_used_mb'], 'o-', color='tab:blue', label='GPU Memory Usage')
        ax1.tick_params(axis='y', labelcolor='tab:blue')
    
    # Only include non-NaN CPU usage values
    cpu_df = df[df['cpu_usage_percent'].notna()]
    if not cpu_df.empty:
        # Create second y-axis for CPU usage
        ax2 = ax1.twinx()
        ax2.set_ylabel('CPU Usage (%)', color='tab:red', fontsize=12)
        ax2.plot(cpu_df['timestamp'], cpu_df['cpu_usage_percent'], 'o-', color='tab:red', label='CPU Usage')
        ax2.tick_params(axis='y', labelcolor='tab:red')
    
    # Add grid
    ax1.grid(True, alpha=0.3)
    
    # Add a legend
    lines1, labels1 = ax1.get_legend_handles_labels()
    if 'ax2' in locals():
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')
    else:
        ax1.legend(loc='upper left')
    
    # Rotate x-axis labels for better readability
    plt.xticks(rotation=45)
    
    # Tight layout to prevent label cutoff
    plt.tight_layout()
    
    # Save or show the plot
    if output_file:
        plt.savefig(output_file)
        print(f"Plot saved to {output_file}")
    else:
        plt.show()

def analyze_performance(df: pd.DataFrame) -> None:
    """Analyze performance data and print insights."""
    if df.empty:
        print("No data to analyze")
        return
    
    print("\n===== Performance Analysis =====")
    
    # CPU usage analysis
    cpu_df = df[df['cpu_usage_percent'].notna()]
    if not cpu_df.empty:
        avg_cpu = cpu_df['cpu_usage_percent'].mean()
        max_cpu = cpu_df['cpu_usage_percent'].max()
        print(f"CPU Usage: avg={avg_cpu:.2f}%, max={max_cpu:.2f}%")
    
    # GPU memory analysis
    gpu_df = df[df['gpu_memory_used_mb'].notna()]
    if not gpu_df.empty:
        avg_gpu = gpu_df['gpu_memory_used_mb'].mean()
        max_gpu = gpu_df['gpu_memory_used_mb'].max()
        print(f"GPU Memory: avg={avg_gpu:.2f}MB, max={max_gpu:.2f}MB")
    
    # Provide insights
    if 'avg_cpu' in locals() and 'avg_gpu' in locals():
        print("\nInsights:")
        if max_cpu > 90:
            print("- High CPU usage detected. Consider increasing GPU offload if possible.")
        
        if max_gpu / avg_gpu > 1.5:
            print("- Significant GPU memory variation. May indicate memory management issues.")
        
        if avg_cpu < 30 and avg_gpu > 0:
            print("- Low CPU utilization with GPU usage indicates good offloading.")
    
    print("================================\n")

def main():
    """Main function to process arguments and run analysis."""
    parser = argparse.ArgumentParser(description="Analyze LLM performance with Metal GPU acceleration")
    parser.add_argument("-l", "--log", help="Path to specific log file or directory")
    parser.add_argument("-o", "--output", help="Output file for plot (e.g., performance.png)")
    parser.add_argument("-a", "--analyze-only", action="store_true", help="Only analyze, don't plot")
    args = parser.parse_args()
    
    # Load monitoring logs
    df = load_monitoring_logs(args.log)
    
    if not df.empty:
        # Analyze performance
        analyze_performance(df)
        
        # Plot results unless analyze-only flag is set
        if not args.analyze_only:
            plot_memory_usage(df, args.output)
    else:
        print("No data available for analysis.")

if __name__ == "__main__":
    # Create monitoring directory if it doesn't exist
    os.makedirs("monitoring", exist_ok=True)
    
    # Run main function
    main() 